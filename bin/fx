#!/usr/bin/env bash
#
# fx -- a simple utility to print ansi styles and colors
#

# exit with an error message
abort() {
  printf "\e[31mError\e[0m %s\n" "${*}"
  exit 1
}

debug() {
  return
  printf "\e[33m>\e[0m %s\n" "${*}"
}

# print 16 colors and names
colors_16() {
  local code style layer varient name

  echo
  for style in 0 7; do                   # default, invert
    for varient in 3 9; do               # normal, light
      printf " "
      for i in {0..9}; do                # color digit
        [[ $i -eq 8 ]] && continue

        show_color -n $style $varient $i
      done
      echo
    done
  done
  echo
}

# print 256 colors
#
# usage: colors_256 [fg|bg]
#
colors_256() {
  local layer="${1:-fg}" style

  case "${layer}" in
    fg)  style=0 ;;
    bg)  style=7 ;;
  esac

  echo
  for i in {0..255} ; do
    printf "  \e[%d;38;5;%sm%3s\e[0m  " ${style} $i $i
    [ $(( (i+1) % 10)) -eq 0 ] && echo
  done
  printf "\n\n"
}

# print styles
styles() {
  local name

  echo
  for i in {0..9}; do
    name=${styles[$i]}
    [[ "$name" == "skip" ]] && continue
    printf " \e[%dm[%s:%d]\e[0m " $i "${name}" $i
  done
  printf "\n\n"
}

# print usage information
usage() {
  cat <<END
  fx -- a simple utility to print available styles and colors

  usage: fx [16|256|style|all]
         fx 256 --bg
         fx --to-rgb HEX_CODE
         fx --to-hex R G B [A]
         fx --to-dec R G B [A]
         fx --get-rgb CODE
         fx --get-hex CODE
END
}

valid_256() {
  [[ "$1" =~ ^[0-9]+$ ]] && [[ $1 -le 255 ]]
}

valid_hex() {
  local string="${1}"
  [[ "$string" =~ ^[a-zA-Z0-9]+$ ]] && [[ ${#string} =~ ^[3684]$ ]]
}

valid_code() {
  local code=$1

  [[ ${#code} =~ ^[123]$ ]] || return 1
  [[ $code =~ ^[349]?[012345679]$ ]] || [[ $code =~ ^10[012345679]$ ]]
}

valid_color() {
  printf "%s\n" "${colors[@]}" bright light | grep -xq $1
}

valid_style() {
  printf "%s\n" "${styles[@]}" | grep -xq $1
}

valid_name() {
  valid_color $1 || valid_style $1
}

# convert a series of rgb values to a hex string
#
# usage: rgb_to_hex R G B [A]

# examples:
#
# $ rgb_to_hex 255 255 255
# #ffffff
# $ rgb_to_hex 0 0 0
# #000000
#
rgb_to_hex() {
  local string="#" code

  while [[ $# -gt 0 ]]; do
    valid_256 $1 || abort "invalid RGB value: '$1'"

    code=$(printf %x $1)
    [[ ${#code} -eq 1 ]] && code="${code}${code}"
    string="${string}${code}"
    shift
  done

  echo $string
}

# convert a hex string to a series of rgb values
#
# usage: hex_to_rgb HEX

# examples:
#
# $ hex_to_rgb ffffff
# 255 255 255
# $ hex_to_rgb fff
# 255 255 255
# $ hex_to_rgb '#ffffff'
# 255 255 255
#
hex_to_rgb() {
  local string="${1###}" len=2 code value rgb

  valid_hex "${string}" || abort "Invalid hex code: '$(printf "%q" "${1}")'"

  # get one character at a time for 3 or 4 digit codes
  [[ ${#string} =~ ^[34]$ ]] && len=1

  while [[ ${#string} -gt 0 ]]; do
    # get the first 1-2 characters
    code="${string:0:$len}"

    # expand for 3 digit codes
    [[ ${#code} -eq 1 ]] && code="${code}${code}"

    # get the decimal value for this code
    #    the { ; } is to redirect stderr for parsing
    #    errors that result from invalid hex codes
    value=$({ echo $((16#$code)) ; } 2> /dev/null)

    # if the above failed, then $value will be empty so abort
    [[ -z "$value" ]]  && abort "Not a valid hex code: '${1}' ('${code}')"

    # append to rgb string
    rgb="${rgb}${rgb:+ }$value"

    # remove characters from the string
    string="${string:$len}"
  done

  echo $rgb
}

# convert a series of RGB values in percentages to decimal rgb values
#
# usage percent_to_rgb R G B [A]
#
# example:
# $ percent_to_rgb 1 0.51372170448303223 0.45018774271011353
# 255 130 114
#
percent_to_rgb() {
  local value rgb

  while [[ $# -gt 0 ]]; do
    [[ "$1" =~ ^[0-9.]*$ ]] || abort "Not a valid argument: '$1'"

    value=$(bc <<< "$1*255")

    # append to rgb string
    rgb="${rgb}${rgb:+ }${value%%.*}"

    shift
  done

  echo $rgb
}

get_hex() {
  local ofs="$IFS" IFS=':/' color_num=$1 r g b c

  # this is a guess -- doesn't work with 3.2.57 though
  [[ ${BASH_VERSINFO[0]} -lt 4 ]] && abort "This feature requires bash 4+"

  # responds with someting like:
  # 4;1;rgb:ca2d/1b53/0000\a\e\\
  read -sr -t 0.1 -d $'\a' -p "$(printf '\e]4;%d;?\a' "$color_num")" _ r g b

  b=${b%%$'\e'*} # strip trailing escape characters

  IFS="$ofs"

  [[ -z "$r" ]] && abort "Failed to query for color value."

  echo "${r:0:2}${g:0:2}${b:0:2}"
}

get_rgb() {
  hex_to_rgb $(get_hex $1)
}

show_rgb() {
  local sep=$'\n' code display

  if [[ $1 == "-i" ]]; then
    sep=" "
    printf "\e[7m"
    shift
  fi

  printf "\e[38;2;%d;%d;%d;m%s\e[0m%s" $@ "$*" "$sep"
}

show_hex() {
  local rgb
  rgb="$(hex_to_rgb $1)"

  show_rgb -i ${rgb[@]}
  show_rgb ${rgb[@]}
}

show_code() {
  local sep=$'\n' code display

  if [[ $1 == "-n" ]]; then
    sep="  "
    shift
  fi

  code="$1" display="${2:-$1}"

  printf "\e[%dm%s\e[0m%s" $code "$display" "$sep"
}

show_256() {
  local sep=$'\n' color
  if [[ $1 == "-i" ]]; then
    sep=" "
    shift
    printf "\e[7m"
  fi

  printf "\e[38;5;%d;m%s\e[0m%s" $1 $1 "$sep"
}

color_by_name() {
  local varient=3 name="" color code display layer

  if [[ "$1" =~ ^(light|bright) ]]; then
    name="$1 "
    varient=9
    shift
  fi

  color="${color_map[$1]}"

  show_color -n 0 $varient $color "$name"
  show_color    7 $varient $color "$name"
}

# usage: show_color [-n] STYLE=0|7 VARIENT=3|9 COLOR=1-9 [PREFIX="bright|light "]
#
# examples:
#
# $ show_color 0 3 4         # fg normal blue
# $ show_color 7 9 5         # bg bright magenta
#
show_color() {
  local sep=$'\n' style varient color prefix
  local layer code name display

  if [[ $1 == "-n" ]]; then
    sep=" "
    shift
  fi

  style=$1 varient=$2 color=$3 prefix="$4"

  [[ $style =~ ^[07]$ ]] || abort "Invalid style: '${style}' (ok: 0=normal, 7=invert)"
  [[ $varient =~ ^[39]$ ]] || abort "Invalid varient '${varient}' (ok: 3=normal, 9=bright)"
  [[ $color =~ ^[012345679]$ ]] || abort "Invalid color '${color}' (ok: 0-9 except 8)"

  layer=$varient                   # fg / bg
  if [[ $style -eq 7 ]]; then
    case $varient in
      3) layer=4  ;;
      9) layer=10 ;;
    esac
  fi

  name="${prefix}${colors[$color]}"              # color name
  code="${varient}${color}"
  display="${layer}${color}"

  printf "\e[%d;%dm[%s:%3s]\e[0m%s" $style $code "$name" $display "$sep"
}

show_style() {
  show_code ${style_map[$1]} $1
}

# usage: show [args...]
#
# example:
#
# [x] $ show 135 95 255
# [x] $ show yellow
# [x] $ show '#fffc00'
# [x] $ show 94              # 16 -- bright blue
# [x] $ show 200             # 256
# [x] $ show bold
# [ ] $ show bright red
show() {
  local flag ok

  if [[ $1 =~ ^[-] ]]; then
    flag="$1"
    shift

  elif [[ $# -eq 3 ]]; then
    flag="--rgb"

  elif valid_color "$1"; then
    flag="--color"

  elif valid_style "$1"; then
    flag="--style"

  elif valid_256 $1; then
    flag="--256"

  elif valid_hex "${1}"; then
    flag="--hex"

  elif valid_code $1; then
    flag="--code"

  fi

  case "$flag" in
    --rgb)
            debug "showing rgb color ${*}"
            show_rgb -i $@
            show_rgb $@
            ;;
    --color)

            debug "showing color by name: ${*}"
            color_by_name "$@"
            ;;
    --style)

            debug "showing style: ${*}"
            show_style "$@"
            ;;
    --256)
            debug "showing 256 color: ${*}"
            show_256 -i $1
            show_256 $1
            ;;

    --hex)
            debug "showing hex color: ${*}"
            show_hex "$1"
            ;;

    --code)
            debug "showing code: ${*}"
            show_code $1
            ;;

    *)
          abort "Unable to figure out the color: ($flag) ${*}"
          ;;
      esac
}

init() {
  local i

  i=0
  for c in "${colors[@]}"; do
    color_map+=( [$c]=$((i++)) )
  done

  i=0
  for s in "${styles[@]}"; do
    style_map+=( [$s]=$((i++)) )
  done
}

main() {
  local type=${1:-256}
  local -a colors=(black red green yellow blue magenta cyan white skip default)
  local -a styles=(default bold dim italic underline blink skip invert hidden strike)
  local -A color_map style_map

  [[ $# -ge 1 ]] && shift

  init

  case $type in
    -h|--help|help)       usage                 ;;
    16|-16)               colors_16             ;;
    -f|--fg|fg|256|-256)  colors_256 fg         ;;
    -b|--bg|bg)           colors_256 bg         ;;
    -s|--style*|style*)   styles                ;;
    --to-hex)             rgb_to_hex $@         ;;
    --to-rgb)             hex_to_rgb $@         ;;
    --to-dec)             percent_to_rgb $@     ;;
    --get-rgb)            get_rgb $@            ;;
    --get-hex)            get_hex $@            ;;
    show)                 show "$@"             ;;
    all)
      {
        styles
        colors_16
        colors_256 fg
        colors_256 bg
      } | ${PAGER:-less -R}
                                                ;;

     *)                   usage ; exit 1        ;;
  esac
}

main ${1:+"$@"}
